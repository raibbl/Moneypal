import { Reducer } from 'redux';
import { PayloadAction, PayloadActionCreator, PrepareAction } from './createAction';
import { CaseReducers, CaseReducer } from './createReducer';
/**
 * An action creator atttached to a slice.
 *
 * @deprecated please use PayloadActionCreator directly
 */
export declare type SliceActionCreator<P> = PayloadActionCreator<P>;
export interface Slice<S = any, AC extends {
    [key: string]: any;
} = {
    [key: string]: any;
}> {
    /**
     * The slice name.
     */
    slice: string;
    /**
     * The slice's reducer.
     */
    reducer: Reducer<S>;
    /**
     * Action creators for the types of actions that are handled by the slice
     * reducer.
     */
    actions: AC;
    /**
     * Selectors for the slice reducer state. `createSlice()` inserts a single
     * selector that returns the entire slice state and whose name is
     * automatically derived from the slice name (e.g., `getCounter` for a slice
     * named `counter`).
     */
    selectors: {
        [key: string]: (state: any) => S;
    };
}
/**
 * Options for `createSlice()`.
 */
export interface CreateSliceOptions<S = any, CR extends SliceCaseReducers<S, any> = SliceCaseReducers<S, any>> {
    /**
     * The slice's name. Used to namespace the generated action types and to
     * name the selector for retrieving the reducer's state.
     */
    slice?: string;
    /**
     * The initial state to be returned by the slice reducer.
     */
    initialState: S;
    /**
     * A mapping from action types to action-type-specific *case reducer*
     * functions. For every action type, a matching action creator will be
     * generated using `createAction()`.
     */
    reducers: CR;
    /**
     * A mapping from action types to action-type-specific *case reducer*
     * functions. These reducers should have existing action types used
     * as the keys, and action creators will _not_ be generated.
     */
    extraReducers?: CaseReducers<S, any>;
}
declare type PayloadActions<T extends keyof any = string> = Record<T, PayloadAction>;
declare type EnhancedCaseReducer<S, A extends PayloadAction> = {
    reducer: CaseReducer<S, A>;
    prepare: PrepareAction<A['payload']>;
};
declare type SliceCaseReducers<S, PA extends PayloadActions> = {
    [T in keyof PA]: CaseReducer<S, PA[T]> | EnhancedCaseReducer<S, PA[T]>;
};
declare type CaseReducerActions<CR extends SliceCaseReducers<any, any>> = {
    [T in keyof CR]: CR[T] extends (state: any) => any ? PayloadActionCreator<void> : (CR[T] extends (state: any, action: PayloadAction<infer P>) => any ? PayloadActionCreator<P> : CR[T] extends {
        prepare: PrepareAction<infer P>;
    } ? PayloadActionCreator<P, string, CR[T]['prepare']> : PayloadActionCreator<void>);
};
declare type NoInfer<T> = [T][T extends any ? 0 : never];
declare type SliceCaseReducersCheck<S, ACR> = {
    [P in keyof ACR]: ACR[P] extends {
        reducer(s: S, action?: {
            payload: infer O;
        }): any;
    } ? {
        prepare(...a: never[]): {
            payload: O;
        };
    } : {};
};
/**
 * A function that accepts an initial state, an object full of reducer
 * functions, and optionally a "slice name", and automatically generates
 * action creators, action types, and selectors that correspond to the
 * reducers and state.
 *
 * The `reducer` argument is passed to `createReducer()`.
 */
export declare function createSlice<S, CR extends SliceCaseReducers<S, any>>(options: CreateSliceOptions<S, CR> & {
    reducers: SliceCaseReducersCheck<S, NoInfer<CR>>;
}): Slice<S, CaseReducerActions<CR>>;
export {};
